/*
 * ExecutionExplorer.h
 * VB Script Analyzer
 * @author Gregoire JACOB (gregoire.jacob@orange-ftgroup.com)
 * @date 21/01/2008
 * @version 1.0
 * Simulate the script execution and analyse the different calls
 * to monitored functions as well as their arguments
 */

//Monitored system functions
/*Generic operations******************/
#define STOP0		"Quit"
/*File operations*********************/
#define OPENF1		"GetFile"
#define	OPENF2		"GetFolder"
#define OPENF3		"OpenTextFile"
#define OPENFT		"FileExists"
#define OPEND1		"GetDrive"
#define OPEND2		"Drives"
#define	OPENDOC		"CreateTextRange"
#define OPENRUN		"Run"
#define CREATEF2	"CreateFolder"
#define	CREATEF3	"CreateTextFile"
#define	CLOSEF1		"Close"
#define DELETEF1	"DeleteFile"
#define	DELETEF2	"DeleteFolder"
#define WRITEF1		"Write"
#define WRITEF2		"WriteLine"
#define WRITEF3		"CopyFile"
#define WRITEF4		"Copy"
#define WRITEF5		"Move"
#define WRITEF6		"MoveFile"
#define READF1		"Read"
#define READF2		"ReadLine"
#define READF3		"ReadAll"
#define READDOC		"HTMLText"
/*Registry operations*****************/
#define DELETER1	"RegDelete"
#define WRITER1		"RegWrite"
#define READR1		"RegRead"
#define READR2		"GetStringValue"
#define READR3		"EnumKey"
/*Mail operations********************/
#define MAILOB1		"CDO.Message"
#define MAILOB2		"cdonts.NewMail"
#define CREATEM1	"CreateItem"
#define WRITEM1		"Textbody"
#define WRITEM2		"Body"
#define WRITEM3		"AddAttachment"
#define WRITEM4		"AttachFile"
#define WRITEM5		"Attachments"

/*Missing expression ********************/
static int isMissing;    //multi-line case

/**
 * printLogEntry()
 * @param the log file in output
 * @param the typing structure from where object information are recovered
 * @param the operation code
 * @param the first parameter identifier (optional)
 * @param the second parameter identifier (optional)
 */
void printLogEntry(FILE * logf, struct TYPING * types,
				   unsigned long operation, int obj1, int obj2);

/**
 * possiblyImbricated()
 * @param the token name
 * @return 1 if this call can be imbricated else 0
 */
int possiblyImbricated(char * name);

/**
 * processExpression()
 * @param the current script structure
 * @param the current script typing structure
 * @param the location inside the script
 * @param the line containing the expression
 * @param the index of the expression in the table
 * @param the nature of the expression
 * @param the significant token (must be previously allocated)
 * @param position of the first token after the expression
 * For a given expression, the reference is resumed to its most significant
 * element (having the highest type).
 */
void processExpression(FILE * logf, struct SCRIPT * script, struct TYPING * types, 
					   unsigned long location, struct LINE * line,	
					   int tokenindex, int nature, char token[TOKENSIZE], int * next);

/**
 * processLine()
 * @param the current script structure
 * @param the current script typing structure
 * @param the current location (main, function or procedure)
 * @param the line structure to process
 * Analyzes a given line without chaining
 */
void processLine(FILE * logf, struct SCRIPT * script, struct TYPING * types, 
				 unsigned long location, struct LINE * line);

/**
 * processLines()
 * processExpression()
 * processConditional()
 * processLoop()
 * @param the current script structure
 * @param the current script typing structure
 * @param the current location (main, function or procedure)
 * @param the current line index
 * @return the next line to process in the location
 * Analyze a line taking into account structure and chaining with other lines 
 */
int processLines(FILE * logf, struct SCRIPT * script, struct TYPING * types, 
				 unsigned long location, int lineindex);
//@param Either "if then else" statement (1), 
//           or "select case" statement (2)
int processConditional(FILE * logf, struct SCRIPT * script, struct TYPING * types,
						unsigned long location, int lineindex, int statement);
//@param Either "for each/to" statement (1), 
//           or "do loop while/until" statement (2),
//           or "while" statement (3)
int processLoop(FILE * logf, struct SCRIPT * script, struct TYPING * types,
				unsigned long location, int lineindex, int statement);

/**
 * monitorSytemCalls()
 * monitorFileControl()			monitorNetworkControl()
 * monitorFileIO()				monitorNetworkIO()
 * monitorMailControl()			monitorRegControl()			
 * monitorMailIO()				monitorRegIO()				
 * @param the current log file where analyzed actions are written down
 * @param the current script structure
 * @param the current script typing structure
 * @param the location in the script of the analyzed line
 * @param the current line under analysis 
 * @return 1 if a system call has been recognized, 0 otherwise
 * Detect the system calls present in the line and translate them
 * into the grammar formalism (log)
 */
int monitorSytemCalls(FILE * logf, struct SCRIPT * script, struct TYPING * types,
					   unsigned long location, struct LINE * line);
//Specialized monitors
int monitorFileControl(FILE * logf, struct SCRIPT * script, struct TYPING * types,
					   unsigned long location, struct LINE * line);
int monitorFileIO(FILE * logf, struct SCRIPT * script, struct TYPING * types,
					   unsigned long location, struct LINE * line);
int monitorRegControl(FILE * logf, struct SCRIPT * script, struct TYPING * types,
					   unsigned long location, struct LINE * line);
int monitorRegIO(FILE * logf, struct SCRIPT * script, struct TYPING * types,
					   unsigned long location, struct LINE * line);
int monitorMailControl(FILE * logf, struct SCRIPT * script, struct TYPING * types,
					   unsigned long location, struct LINE * line);
int monitorMailIO(FILE * logf, struct SCRIPT * script, struct TYPING * types,
					   unsigned long location, struct LINE * line);
//int monitorNetworkControl(FILE * logf, struct SCRIPT * script, struct TYPING * types,
//					   unsigned long location, struct LINE * line);
//int monitorNetworkIO(FILE * logf, struct SCRIPT * script, struct TYPING * types,
//					   unsigned long location, struct LINE * line);*/

/**
 * startFunction()
 * startProcedure()
 * startMain()
 * @param the current log file where analyzed actions are written down
 * @param the current script structure
 * @param the current script typing structure
 * @param when relevant the index of the function or procedure to start
 * @param the line responsible for the procedure/function call (contains parameters)
 * Emulate the script execution without really executing it
 */
void startFunction(FILE * logf, struct SCRIPT * script, 
				   struct TYPING * types, int funcindex, struct LINE * line);
void startProcedure(FILE * logf, struct SCRIPT * script, 
                    struct TYPING * types, int procindex, struct LINE * line);
void startMain(FILE * logf, struct SCRIPT * script, struct TYPING * types);