/*
 * Overinfection.c
 * Behavioral Attributed Automaton
 * @author Gregoire JACOB (gregoire.jacob@orange-ftgroup.com)
 * @date 01/12/2008
 * @version 2.1
 * Overinfection test parser automaton
 */


#include ".\Includes\BehaviorAutomata.h"


void initOverinfectionAutomata(){
	int start[3] = {0,0,0};
	long lstart[3] = {0,0,0};
	overinfection.automata = NULL;
	overinfection.nbnautomata = 0;
	overinfection.nbmaxautomata = 0;
	startAutomaton(&overinfection,'s',lstart,start);
}


void parseOverCreate(long argid, int argtype){
	char curnode;
	long curids[3]; int curtypes[3];
	long final[3] = {0,0,0}; long lfinal[3] = {0,0,0};
	int i, nb = overinfection.nbnautomata;

	for(i=0;i<nb;i++){
		struct PARSED_AUTOMATON * aut = &overinfection.automata[i];
		//Recover the state of the automaton
		curnode = getCurrentState(aut);
		getCurrentAttributes(aut,curids,curtypes);
		switch(curnode){
			
			case 'b': //Test1
				//Checks semantic rules
				if(argtype==TYPE_PERM&&argid==curids[0]){
					//Progression toward the next node
					addNode(aut,'f',lfinal,final);
					printf("[+] Overinfection test 1 has been detected "
						"using marker %s%d \n",typestr[curtypes[0]],
						curids[0]);
					storeBehaviorEntry(pf_BehDB,OVERINFECTION_REF,0,argid,0,0);
					//Create a waiting new automaton replacing the parsed one
					startAutomaton(&overinfection,'s',lfinal,final);
					aut = &overinfection.automata[i]; //Update relocation
					break;
				}	

			case 'd': //Test 2
				//Checks semantic rules
				if(argtype==TYPE_PERM&&argid==curids[0]){
					//Progression toward the next node
					addNode(aut,'f',lfinal,final);
					printf("[+] Overinfection test 2 has been detected "
						"using marker %s%d \n",typestr[curtypes[0]],
						curids[0]);
					storeBehaviorEntry(pf_BehDB,OVERINFECTION_REF,1,argid,0,0);
					//Create a waiting new automaton replacing the parsed one
					startAutomaton(&overinfection,'s',lfinal,final);
					aut = &overinfection.automata[i]; //Update relocation
					break;
				}	

			case 'f':
				break;
			default:
				//Restart automaton (operations must be consecutive)
				aut->nbnode = 1;	
		}//swithch
	}//for
}


void parseOverOpen(long argid, int argtype){
	char curnode;
	long nextids[3] = {0,0,0}; int nextypes[3] = {0,0,0};
	int i, nb = overinfection.nbnautomata;

	for(i=0;i<nb;i++){
		struct PARSED_AUTOMATON * aut = &overinfection.automata[i];
		//Recover the state of the automaton
		curnode = getCurrentState(aut);
		switch(curnode){
			case 'a':
			case 'b':
			case 'c':
				//Restart automaton (operations must be consecutive)
				aut->nbnode = 1;
			case 's': //Initial open
				//Checks semantic rules
				if(argtype==TYPE_PERM){
					//Progression toward the next node
					nextids[0] = argid;
					nextypes[0] = argtype;
					addNode(aut,'a',nextids,nextypes);
					//printf("[+] Reach a by open\n");
					break;
				}
			
			case 'f':
				break;
		}//swithch
	}//for
}


void parseOverTransfer(long arg1id, int arg1type, long arg2id, int arg2type){
	char curnode;
	long curids[3]; int curtypes[3];
	int final[3] = {0,0,0}; long lfinal[3] = {0,0,0};
	int i, nb = overinfection.nbnautomata;

	for(i=0;i<nb;i++){
		struct PARSED_AUTOMATON * aut = &overinfection.automata[i];
		//Test automata in the right state
		curnode = getCurrentState(aut);
		getCurrentAttributes(aut,curids,curtypes);
		switch(curnode){
		
			case 'b': //Test1
				//Checks semantic rules
				if(arg1type>=TYPE_PERM&&arg2type==TYPE_PERM&&arg2id==curids[0]){
					//Progression toward the next node
					addNode(aut,'f',lfinal,final);
					printf("[+] Overinfection test 1 has been detected "
						"using marker %s%d \n",typestr[curtypes[0]],
						curids[0]);
					storeBehaviorEntry(pf_BehDB,OVERINFECTION_REF,0,curids[0],0,0);
					//Create a waiting new automaton replacing the parsed one
					startAutomaton(&overinfection,'s',lfinal,final);
					aut = &overinfection.automata[i]; //Update relocation
					break;
				}	

			case 'd': //Test 2
				//Checks semantic rules
				if(arg1type>=TYPE_PERM&&arg2type==TYPE_PERM&&arg2id==curids[0]){
					//Progression toward the next node
					addNode(aut,'f',lfinal,final);
					printf("[+] Overinfection test 2 has been detected "
						"using marker %s%d \n",typestr[curtypes[0]],
						curids[0]);
					storeBehaviorEntry(pf_BehDB,OVERINFECTION_REF,1,curids[0],0,0);
					//Create a waiting new automaton replacing the parsed one
					startAutomaton(&overinfection,'s',lfinal,final);
					aut = &overinfection.automata[i]; //Update relocation
					break;
				}	
			case 'f':
				break;
			default:
				//Restart automaton (operations must be consecutive)
				aut->nbnode = 1;	
		}//swithch
	}//for
}

void parseOverStop(){
	char curnode;
	long curids[3]; int curtypes[3];
	int i, nb = overinfection.nbnautomata;

	for(i=0;i<nb;i++){
		struct PARSED_AUTOMATON * aut = &overinfection.automata[i];
		//Recover the state of the automaton
		curnode = getCurrentState(aut);
		getCurrentAttributes(aut,curids,curtypes);
		switch(curnode){
			case 'b':
				//Progression toward the next node
				addNode(aut,'c',curids,curtypes);
				//printf("[+] Reach c\n");
				break;
			case 'f':
				break;
			default:
				//Restart automaton (operations must be consecutive)
				aut->nbnode = 1;
		}//swithch
	}//for
}


void parseOverTest1(){
	char curnode;
	long curids[3]; int curtypes[3];
	int i, nb = overinfection.nbnautomata;

	for(i=0;i<nb;i++){
		struct PARSED_AUTOMATON * aut = &overinfection.automata[i];
		//Recover the state of the automaton
		curnode = getCurrentState(aut);
		getCurrentAttributes(aut,curids,curtypes);
		switch(curnode){
			case 'a':
				//Progression toward the next node
				addNode(aut,'b',curids,curtypes);
				//printf("[+] Reach b\n");
				break;
			case 'f':
				break;
			default:
				//Restart automaton (operations must be consecutive)
				aut->nbnode = 1;
		}//swithch
	}//for
}

void parseOverTest2(){
	char curnode;
	long curids[3]; int curtypes[3];
	int i, nb = overinfection.nbnautomata;

	for(i=0;i<nb;i++){
		struct PARSED_AUTOMATON * aut = &overinfection.automata[i];
		//Recover the state of the automaton
		curnode = getCurrentState(aut);
		getCurrentAttributes(aut,curids,curtypes);
		switch(curnode){
			case 'c':
				//Progression toward the next node
				addNode(aut,'d',curids,curtypes);
				//printf("[+] Reach d\n");
				break;
			case 'f':
				break;
			default:
				//Restart automaton (operations must be consecutive)
				aut->nbnode = 1;
		}//swithch
	}//for
}


void updateOverinfectionAutomata(unsigned long operation,
							     long arg1id, int arg1type,
							     long arg2id, int arg2type){
	int i; int nb = overinfection.nbnautomata;

	switch(operation){
		case OP_CREA:
			parseOverCreate(arg1id,arg1type);
			break;
		case OP_OPEN:
			parseOverOpen(arg1id,arg1type);
			break;
		case OP_WRITE:
			parseOverTransfer(arg1id,arg1type,arg2id,arg2type);
			break;
		case L_COND:
			parseOverTest1();
			break;
		case M_COND:
			parseOverTest2();
			break;
		case OP_STOP:
			parseOverStop();
			break;
		default:
			//Restart automata (consecutive operations)
			for(i=0;i<nb;i++){
				if(getCurrentState(&overinfection.automata[i])!='f'){
					overinfection.automata[i].nbnode = 1;
				}
			}
	}
}