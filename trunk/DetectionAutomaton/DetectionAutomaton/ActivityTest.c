/*
 * ActivityTest.c
 * Behavioral Attributed Automaton
 * @author Gregoire JACOB (gregoire.jacob@orange-ftgroup.com)
 * @date 01/12/2008
 * @version 2.2
 * Activity test parser automaton
 */

#include ".\Includes\BehaviorAutomata.h"


void initActivityAutomata(){
	int start[3] = {0,0,0};
	long lstart[3] = {0,0,0};
	activity.automata = NULL;
	activity.nbnautomata = 0;
	activity.nbmaxautomata = 0;
	startAutomaton(&activity,'s',lstart,start);
}


void parseActCreate(long argid, int argtype){
	char curnode;
	long curids[3]; int curtypes[3];
	int final[3] = {0,0,0};
	long lfinal[3] = {0,0,0};
	int i, nb = activity.nbnautomata;

	for(i=0;i<nb;i++){
		struct PARSED_AUTOMATON * aut = &activity.automata[i];
		//Recover the state of the automaton
		curnode = getCurrentState(aut);
		getCurrentAttributes(aut,curids,curtypes);
		switch(curnode){
			
			case 'b': //Test1
				//Checks semantic rules
				if(argtype==TYPE_TEMP&&argid==curids[0]){
					//Progression toward the next node
					addNode(aut,'f',lfinal,final);
					printf("[+] Activity test 1 has been detected "
						"using marker %s%d \n",typestr[curtypes[0]],
						curids[0]);
					//Create a waiting new automaton replacing the parsed one
					startAutomaton(&activity,'s',lfinal,final);
					aut = &activity.automata[i]; //Update relocation
					break;
				}	

			case 'd': //Test 2
				//Checks semantic rules
				if(argtype==TYPE_TEMP&&argid==curids[0]){
					//Progression toward the next node
					addNode(aut,'f',lfinal,final);
					printf("[+] Activity test 2 has been detected "
						"using marker %s%d \n",typestr[curtypes[0]],
						curids[0]);
					//Create a waiting new automaton replacing the parsed one
					startAutomaton(&activity,'s',lfinal,final);
					aut = &activity.automata[i]; //Update relocation
					break;
				}	

			case 'f':
				break;
			default:
				//Restart automaton (operations must be consecutive)
				aut->nbnode = 1;	
		}//swithch
	}//for
}


void parseActOpen(long argid, int argtype){
	char curnode;
	long nextids[3] = {0,0,0}; int nextypes[3] = {0,0,0};
	int i, nb = activity.nbnautomata;

	for(i=0;i<nb;i++){
		struct PARSED_AUTOMATON * aut = &activity.automata[i];
		//Recover the state of the automaton
		curnode = getCurrentState(aut);
		switch(curnode){
			case 'a':
			case 'b':
			case 'c':
				//Restart automaton (operations must be consecutive)
				aut->nbnode = 1;
			case 's': //Initial open
				//Checks semantic rules
				if(argtype==TYPE_TEMP){
					//Progression toward the next node
					nextids[0] = argid;
					nextypes[0] = argtype;
					addNode(aut,'a',nextids,nextypes);
					//printf("[+] Reach a by open\n");
					break;
				}
			
			case 'f':
				break;
		}//swithch
	}//for
}


void parseActStop(){
	char curnode;
	long curids[3]; int curtypes[3];
	int i, nb = activity.nbnautomata;

	for(i=0;i<nb;i++){
		struct PARSED_AUTOMATON * aut = &activity.automata[i];
		//Recover the state of the automaton
		curnode = getCurrentState(aut);
		getCurrentAttributes(aut,curids,curtypes);
		switch(curnode){
			case 'b':
				//Progression toward the next node
				addNode(aut,'c',curids,curtypes);
				//printf("[+] Reach c\n");
				break;
			case 'f':
				break;
			default:
				//Restart automaton (operations must be consecutive)
				aut->nbnode = 1;
		}//swithch
	}//for
}


void parseActTest1(){
	char curnode;
	long curids[3]; int curtypes[3];
	int i, nb = activity.nbnautomata;

	for(i=0;i<nb;i++){
		struct PARSED_AUTOMATON * aut = &activity.automata[i];
		//Recover the state of the automaton
		curnode = getCurrentState(aut);
		getCurrentAttributes(aut,curids,curtypes);
		switch(curnode){
			case 'a':
				//Progression toward the next node
				addNode(aut,'b',curids,curtypes);
				//printf("[+] Reach b\n");
				break;
			case 'f':
				break;
			default:
				//Restart automaton (operations must be consecutive)
				aut->nbnode = 1;
		}//swithch
	}//for
}

void parseActTest2(){
	char curnode;
	long curids[3]; int curtypes[3];
	int i, nb = activity.nbnautomata;

	for(i=0;i<nb;i++){
		struct PARSED_AUTOMATON * aut = &activity.automata[i];
		//Recover the state of the automaton
		curnode = getCurrentState(aut);
		getCurrentAttributes(aut,curids,curtypes);
		switch(curnode){
			case 'c':
				//Progression toward the next node
				addNode(aut,'d',curids,curtypes);
				//printf("[+] Reach d\n");
				break;
			case 'f':
				break;
			default:
				//Restart automaton (operations must be consecutive)
				aut->nbnode = 1;
		}//swithch
	}//for
}


void updateActivityAutomata(unsigned long operation,
							long arg1id, int arg1type,
							long arg2id, int arg2type){
	int i; int nb = activity.nbnautomata;

	switch(operation){
		case OP_CREA:
			parseActCreate(arg1id,arg1type);
			break;
		case OP_OPEN:
			parseActOpen(arg1id,arg1type);
			break;
		case L_COND:
			parseActTest1();
			break;
		case M_COND:
			parseActTest2();
			break;
		case OP_STOP:
			parseActStop();
			break;
		default:
			//Restart automata (consecutive operations)
			for(i=0;i<nb;i++){
				if(getCurrentState(&activity.automata[i])!='f'){
					activity.automata[i].nbnode = 1;
				}
			}
	}
}