/*
 * Propagation.c
 * Behavioral Attributed Automaton
 * @author Gregoire JACOB (gregoire.jacob@orange-ftgroup.com)
 * @date 01/12/2008
 * @version 2.1
 * Propagation parser automaton
 */

#include ".\Includes\BehaviorAutomata.h"


void initPropagationAutomata(){
	int start[3] = {0,0,0};
	long lstart[3] = {0,0,0};
	propagation.automata = NULL;
	propagation.nbnautomata = 0;
	propagation.nbmaxautomata = 0;
	startAutomaton(&propagation,'s',lstart,start);
}


void parsePropCreate(long argid, int argtype){
	char curnode;
	long curids[3]; int curtypes[3];
	long nextids[3] = {0,0,0}; int nextypes[3] = {0,0,0};
	int i, nb = propagation.nbnautomata;

	for(i=0;i<nb;i++){
		struct PARSED_AUTOMATON * aut = &propagation.automata[i];
		//Recover the state of the automaton
		curnode = getCurrentState(aut);
		getCurrentAttributes(aut,curids,curtypes);
		switch(curnode){
			
			case 's': //Initial creation
				if(PropObjectCombin[argid][argid]==1) break;
				//Checks semantic rules
				if(argtype==TYPE_COM){
					//Create a waiting new automaton replacing the parsed one
					startAutomaton(&propagation,'s',nextids,nextypes);
					aut = &propagation.automata[i]; //Update relocation
					//Progression toward the next node
					nextids[0] = argid;
					nextypes[0] = argtype;
					addNode(aut,'a',nextids,nextypes);
					PropObjectCombin[argid][argid] = 1;
					//printf("[+] Reach a by create\n");
				}
				break;

			case 'b': //Already open file
				if(argid==curids[0]) break;
				if(PropObjectCombin[curids[0]][argid]==1) break;
				//Checks semantic rules
				if(argtype==TYPE_COM &&
					curtypes[0]==TYPE_THIS){
					//Create a waiting new automaton replacing the parsed one
					startAutomaton(&propagation,'b',curids,curtypes);
					aut = &propagation.automata[i]; //Update relocation
					//Progression toward the next node
					curids[1] = argid;
					curtypes[1] = argtype;
					addNode(aut,'c',curids,curtypes);
					PropObjectCombin[curids[0]][argid] = 1;
					//printf("[+] Reach c by open/create \n");
				}
				break;

			case 'm': //Already open and read file (this)
				if(argid==curids[0]) break;
				//Checks semantic rules
				if(argtype==TYPE_COM){
					//Create a waiting new automaton replacing the parsed one
					startAutomaton(&propagation,'m',curids,curtypes);
					aut = &propagation.automata[i]; //Update relocation
					//Progression toward the next node
					curids[1] = argid;
					curtypes[1] = argtype;
					addNode(aut,'d',curids,curtypes);
					//printf("[+] Reach d by open \n");
				}
				break;
		}//swithch
	}//for
}


void parsePropOpen(long argid, int argtype){
	char curnode;
	long curids[3]; int curtypes[3];
	long nextids[3] = {0,0,0}; int nextypes[3] = {0,0,0};
	int i, nb = propagation.nbnautomata;

	for(i=0;i<nb;i++){
		struct PARSED_AUTOMATON * aut = &propagation.automata[i];
		//Recover the state of the automaton
		curnode = getCurrentState(aut);
		getCurrentAttributes(aut,curids,curtypes);
		switch(curnode){
			
			case 's': //Initial open
				if(PropObjectCombin[argid][argid]==1) break;
				//Checks semantic rules
				if(argtype==TYPE_COM || argtype==TYPE_THIS 
					|| isDuplicata(argid,argtype)){
					//Create a waiting new automaton replacing the parsed one
					startAutomaton(&propagation,'s',nextids,nextypes);
					aut = &propagation.automata[i]; //Update relocation
					//Progression toward the next node
					nextids[0] = argid;
					nextypes[0] = argtype;
					addNode(aut,'b',nextids,nextypes);
					PropObjectCombin[argid][argid] = 1;
					//printf("[+] Reach b by open type: %d (this:5-perm:2)\n",argtype);
				}
				break;

			case 'a': //Already created file
				if(argid==curids[0]) break;
				if(PropObjectCombin[curids[0]][argid]==1) break;
				//Checks semantic rules
				if(argtype==TYPE_THIS||isDuplicata(argid,argtype)){
					//Create a waiting new automaton replacing the parsed one
					startAutomaton(&propagation,'a',curids,curtypes);
					aut = &propagation.automata[i]; //Update relocation
					//Progression toward the next node
					curids[1] = argid;
					curtypes[1] = argtype;
					addNode(aut,'c',curids,curtypes);
					PropObjectCombin[curids[0]][argid] = 1;
					//printf("[+] Reach c by creat/open \n");
				}
				break;

			case 'b': //Already open file (this)
				if(argid==curids[0]) break;
				if(PropObjectCombin[curids[0]][argid]==1) break;
				//Checks semantic rules
				if((argtype==TYPE_COM && 
					(curtypes[0]==TYPE_THIS||isDuplicata(curids[0],curtypes[0])))
					|| ((argtype==TYPE_THIS ||isDuplicata(argid,argtype))
					&& curtypes[0]==TYPE_COM)){
					//Create a waiting new automaton replacing the parsed one
					startAutomaton(&propagation,'b',curids,curtypes);
					aut = &propagation.automata[i]; //Update relocation
					//Progression toward the next node
					curids[1] = argid;
					curtypes[1] = argtype;
					addNode(aut,'c',curids,curtypes);
					PropObjectCombin[curids[0]][argid] = 1;
					//printf("[+] Reach c by open/open \n");
				}
				break;

			case 'm': //Already open and read file (this)
				if(argid==curids[0]) break;
				//Checks semantic rules
				if(argtype==TYPE_COM){
					//Create a waiting new automaton replacing the parsed one
					startAutomaton(&propagation,'m',curids,curtypes);
					aut = &propagation.automata[i]; //Update relocation
					//Progression toward the next node
					curids[1] = argid;
					curtypes[1] = argtype;
					addNode(aut,'d',curids,curtypes);
					//printf("[+] Reach d by open \n");
				}
				break;
		}//swithch
	}//for
}

void parsePropClose(long argid, int argtype){
	char curnode;
	long curids[3]; int curtypes[3];
	int i, nb = propagation.nbnautomata;

	for(i=0;i<nb;i++){
		struct PARSED_AUTOMATON * aut = &propagation.automata[i];
		//Recover the state of the automaton
		curnode = getCurrentState(aut);
		getCurrentAttributes(aut,curids,curtypes);
		switch(curnode){
			
			case 'a': //Initial open or create
			case 'b':
				if(argid==curids[0]&&argtype==curtypes[0]){
					//Object is close before any propagation-related operation
					deleteAutomaton(&propagation,i);
					i--; nb--;
					PropObjectCombin[argid][argid] = 0;
				}
				break;

			case 'c':	
				if(argid==curids[0]&&argtype==curtypes[0]){
					//Object is close before any propagation-related operation
					deleteAutomaton(&propagation,i);
					i--; nb--;
					PropObjectCombin[argid][curids[1]] = 0;
				}else if(argid==curids[1]&&argtype==curtypes[1]){
					//Object is close before any propagation-related operation
					deleteAutomaton(&propagation,i);
					i--; nb--;
					PropObjectCombin[curids[0]][argid] = 0;
				}
				break;
		}//swithch
	}//for
}

void parsePropRead(long arg1id, int arg1type, long arg2id, int arg2type){
	char curnode;
	long curids[3]; int curtypes[3];
	int i, nb = propagation.nbnautomata;

	for(i=0;i<nb;i++){
		struct PARSED_AUTOMATON * aut = &propagation.automata[i];
		//Recover the state of the automaton
		curnode = getCurrentState(aut);
		getCurrentAttributes(aut,curids,curtypes);
		switch(curnode){

			case 'b': //Already open file (this)
				//Checks semantic rules
				if(arg1type==TYPE_VAR && arg2id==curids[0] &&
					(arg2type==TYPE_THIS||isDuplicata(arg2id,arg2type))){
					//Create a waiting new automaton replacing the parsed one
					startAutomaton(&propagation,'b',curids,curtypes);
					aut = &propagation.automata[i]; //Update relocation
					//Progression toward the next node
					curids[2] = arg1id;
					curtypes[2] = arg1type;
					addNode(aut,'m',curids,curtypes);
					//printf("[+] Reach m by read \n");
				}
				break;
			
			case 'c': //Simple read
				//Checks semantic rules
				if(arg1type==TYPE_VAR && 
					(arg2type==TYPE_THIS||isDuplicata(arg2id,arg2type)) &&
					(arg2id==curids[0] || arg2id==curids[1])){
					//Create a waiting new automaton replacing the parsed one
					startAutomaton(&propagation,'c',curids,curtypes);
					aut = &propagation.automata[i]; //Update relocation
					//Progression toward the next node
					if(arg2id==curids[1]){ //Reordering objects
						curids[1] = curids[0];
						curtypes[1] = curtypes[0];
						curids[0] = arg2id;
						curtypes[0] = arg2type;
					}
					curids[2] = arg1id;
					curtypes[2] = arg1type;
					addNode(aut,'d',curids,curtypes);
					//printf("[+] Reach d by read\n");
				}
				break;

			case 'i': //Interleaved read
				//Checks semantic rules
				if(arg1type==TYPE_VAR && 
					(arg2type==TYPE_THIS||isDuplicata(arg2id,arg2type)) &&
					(arg2id==curids[0] || arg2id==curids[1])){
					//Create a waiting new automaton replacing the parsed one
					startAutomaton(&propagation,'i',curids,curtypes);
					aut = &propagation.automata[i]; //Update relocation
					//Progression toward the next node
					if(arg2id==curids[1]){ //Reordering objects
						curids[1] = curids[0];
						curtypes[1] = curtypes[0];
						curids[0] = arg2id;
						curtypes[0] = arg2type;
					}
					curids[2] = arg1id;
					curtypes[2] = arg1type;
					addNode(aut,'j',curids,curtypes);
					//printf("[+] Reach j by read\n");
				}
				break;

			/*case 'j': //Overwriting a read value
			case 'd':
				if(arg1id==curids[2]&&arg1type==curtypes[2]){
					//Variable is overwritten before any propagation-related operation
					setCurrentState('e',aut); //Error state (no more progression)
				}
				break;*/
		}//swithch
	}//for
}

void parsePropWrite(long arg1id, int arg1type, long arg2id, int arg2type){
	char curnode;
	long curids[3]; int curtypes[3];
	int final[3] = {0,0,0}; long lfinal[3] = {0,0,0};
	int i, nb = propagation.nbnautomata;

	for(i=0;i<nb;i++){
		struct PARSED_AUTOMATON * aut = &propagation.automata[i];
		//Recover the state of the automaton
		curnode = getCurrentState(aut);
		getCurrentAttributes(aut,curids,curtypes);
		switch(curnode){
			
			case 'd': //Simple write
				//Checks semantic rules
				if(arg1type==TYPE_VAR && arg1id==curids[2] &&
					arg2type==TYPE_COM && arg2id==curids[1]){
					//Progression toward the next node
					addNode(aut,'f',lfinal,final);
					printf("[+] Simple propagation has been detected"
						" between %s%d and %s%d through %s%d\n",typestr[curtypes[0]],curids[0],
						typestr[curtypes[1]],curids[1],typestr[curtypes[2]],curids[2]);
					storeBehaviorEntry(pf_BehDB,PROPAGATION_REF,1,
									   curids[0],curids[1],curids[2]);
				}
				break;

			case 'j': //Interleaved write
				//Checks semantic rules
				if(arg1type==TYPE_VAR && arg1id==curids[2] &&
					arg2type==TYPE_COM && arg2id==curids[1]){
					//Progression toward the next node
					addNode(aut,'k',curids,curtypes);
					//printf("[+] Reach k by write\n");
				}
				break;
		}//swithch
	}//for
}



void parsePropDirectTransfer(long arg1id, int arg1type, long arg2id, int arg2type){
	char curnode;
	int final[3] = {0,0,0}; long lfinal[3] = {0,0,0};
	int i, nb = propagation.nbnautomata;

	for(i=0;i<nb;i++){
		struct PARSED_AUTOMATON * aut = &propagation.automata[i];
		//Test automata in the right state
		curnode = getCurrentState(aut);
		if(curnode!='s') continue;
		//Checks semantic rules
		if((arg1type==TYPE_THIS||isDuplicata(arg1id,arg1type))
			&& arg2type==TYPE_COM){
			//Create a waiting new automaton replacing the parsed one
			startAutomaton(&propagation,'s',lfinal,final);
			aut = &propagation.automata[i]; //Update relocation
			//Progression toward the next node
			addNode(aut,'f',lfinal,final);
			printf("[+] Transfer propagation has been detected between %s%d and %s%d\n",
				typestr[arg2type],arg2id,typestr[arg1type],arg1id);
			storeBehaviorEntry(pf_BehDB,PROPAGATION_REF,0,arg1id,arg2id,0);
		}
	}
}

void parsePropAffect(long arg1id, int arg1type, long arg2id, int arg2type){
	char curnode;
	long curids[3]; int curtypes[3];
	int i, nb = propagation.nbnautomata;

	for(i=0;i<nb;i++){
		struct PARSED_AUTOMATON * aut = &propagation.automata[i];
		//Recover the state of the automaton
		curnode = getCurrentState(aut);
		getCurrentAttributes(aut,curids,curtypes);
		switch(curnode){
			
			case 'd': //Simple copy
				//Checks semantic rules
				if(arg1type<=TYPE_VAR && arg2type==TYPE_VAR &&
					arg2id==curids[2]){
					//Start a parallel automaton with new variable
					curids[2] = arg1id;
					startAutomaton(&propagation,'d',curids,curtypes);
					//printf("[+] Automaton divergence after affectation\n");
				}
				break;

			case 'j': //Interleaved copy
				//Checks semantic rules
				if(arg1type==TYPE_VAR && arg2type==TYPE_VAR &&
					arg2id==curids[2]){
					//Start a parallel automaton with new variable
					curids[2] = arg1id;
					startAutomaton(&propagation,'j',curids,curtypes);
					//printf("[+] Automaton divergence after affectation\n");
				}
				break;
		}//swithch
	}//for
}


void parsePropInterleavedBegin(){
	char curnode;
	long curids[3]; int curtypes[3];
	int i, nb = propagation.nbnautomata;

	for(i=0;i<nb;i++){
		struct PARSED_AUTOMATON * aut = &propagation.automata[i];
		//Recover the state of the automaton
		curnode = getCurrentState(aut);
		getCurrentAttributes(aut,curids,curtypes);
		if(curnode!='c') continue;
		//Progression toward the next node
		addNode(aut,'i',curids,curtypes);
		//printf("[+] Reach i\n");
	}//for
}


void parsePropInterleavedEnd(){
	char curnode;
	int final[3] = {0,0,0}; long lfinal[3] = {0,0,0};
	long curids[3]; int curtypes[3];
	int i, nb = propagation.nbnautomata;

	for(i=0;i<nb;i++){
		struct PARSED_AUTOMATON * aut = &propagation.automata[i];
		//Recover the state of the automaton
		curnode = getCurrentState(aut);
		getCurrentAttributes(aut,curids,curtypes);
		switch(curnode){
			
			case 'k': //End of interleaved copy
				//Progression toward the next node
				addNode(aut,'f',lfinal,final);
				printf("[+] Interleaved propagation has been detected"
					" between %s%d and %s%d through %s%d\n",typestr[curtypes[0]],curids[0],
						typestr[curtypes[1]],curids[1],typestr[curtypes[2]],curids[2]);
				storeBehaviorEntry(pf_BehDB,PROPAGATION_REF,2,
								   curids[0],curids[1],curids[2]);
				break;

			case 'i': //Close loop
				//Return to state c 
				setCurrentState('c',aut);
				//printf("[+] Return to c\n");
				break;

			case 'j': //Close loop
				//Switch to state d
				setCurrentState('d',aut);
				break;
		}//swithch
	}//for
}


void updatePropagationAutomata(unsigned long operation,
							   long arg1id, int arg1type,
							   long arg2id, int arg2type){
	switch(operation){
		case OP_CREA:
			parsePropCreate(arg1id,arg1type);
			break;
		case OP_OPEN:
			parsePropOpen(arg1id,arg1type);
			break;
		case OP_CLOS:
			parsePropClose(arg1id,arg1type);
			break;
		case OP_READ:
			parsePropRead(arg1id,arg1type,arg2id,arg2type);
			break;
		case OP_WRITE:
			parsePropDirectTransfer(arg1id,arg1type,arg2id,arg2type);
			parsePropWrite(arg1id,arg1type,arg2id,arg2type);
			break;
		case OP_AFF:
			parsePropAffect(arg1id,arg1type,arg2id,arg2type);
			break;
		case L_LOOP:
			parsePropInterleavedBegin();
			break;
		case R_LOOP:
			parsePropInterleavedEnd();
			break;
		//default:
			//ignore operation
	}

}