/*
 * ExecutionExplorer.c
 * NtTrace Analyzer
 * @author Gregoire JACOB (gregoire.jacob@orange-ftgroup.com)
 * @date 03/09/2008
 * @version 1.0
 * Parse process trace and analyse the different calls
 * to monitored functions as well as their arguments
 */

#include ".\Includes\Analyzer.h"

//avoid path ambiguities
void pathCompletion(char * path){
	char name[NAME_MAX_LENGTH]; int i = 0; 
	//Unquoting and removing blanks
	while(path[i] == ' ' || path[i] == '"'){i++;}
	path+=i;

	if(strchr(path,'\\')==NULL){
		strcpy(name,path);
		strcpy(path,"\\??\\C:\\Dokumente und Einstellungen\\Administrator\\Desktop\\NtTrace\\");
		strcat(path,name);
	}
	if(strncmp(path,"\\??\\",4) && strncmp(path,"\\Device\\",8)){
		strcpy(name,path);
		strcpy(path,"\\??\\");
		strcat(path,name);
	}
}

void processLine(FILE * logf, struct TYPING * types, char * line){
	unsigned long opcall = 0; 
	int i, obj1 = 0, obj2 = 0;

	int buffer, size;
	unsigned long address, address2, diff;
	
	//printf("[+0] %s\n", line);
	opcall = monitorFileControl(types,line,&obj1);
	//printf("[+1] %s\n", line);
	if (!opcall) opcall = monitorFileIO(types,line,&obj1,&obj2);
	if (!opcall) opcall = monitorRegControl(types,line,&obj1);
	if (!opcall) opcall = monitorRegIO(types,line,&obj1,&obj2);
	if (!opcall) opcall = monitorNetworkControl(types,line,&obj1);
	if (!opcall) opcall = monitorNetworkIO(types,line,&obj1,&obj2);
		
	if(opcall)formatLogEntries(logf,types,opcall,obj1,obj2);

	//Special case for Network reading (may be duplicated in a buffer 0x500 bytes further)
	if(opcall == OP_READ && getObjectNature(types,obj2)==OBJ_NETW){
		address = getObjectAddress(types,obj1);
		size = getObjectSize(types,obj1);
		address += 1280;
		buffer = 0;
		for(i=0;i<types->nbobj;i++){
				unsigned long add = getObjectAddress(types,i);
				if(add==address){
					buffer = i;
					break;
				}
		}
		if(!buffer){
			buffer = addNewObject(types,NULL,VAR);
			setObjectAddress(types,buffer,address);
		}
		setObjectSize(types,buffer,size);
		/*buffer = isKnownObject(types,NULL,address);
		if(buffer==-1){
			buffer = addNewObject(types,NULL,VAR);
			setObjectAddress(types,buffer,address);
			setObjectSize(types,buffer,size);
		}else{
			address2 = getObjectAddress(types,buffer);
			if(address != address2){
				//Create new variable
				buffer = addNewObject(types,NULL,VAR);
				setObjectAddress(types,buffer,address);
			}
			setObjectSize(types,buffer,size);
		}*/
		formatLogEntries(logf,types,OP_AFF,buffer,obj1);
	}
}

/** Begin System call monitoring ************************************************************/
unsigned long monitorFileControl(struct TYPING * types, char * line, int * obj1){
	char * args = NULL; 
	char * token; char * objtoken1; char * objtoken2;
	char * filename; unsigned long ptr1, handle1, ptr2, handle2;
	int objind;

	if(!strncasecmp(OPENF1,line,10)){//NtOpenFile Size n=strlen(OPENF1)-1)
		args = strchr(line,'(');
		if(args){
			//Parse arguments
			args++;
			objtoken1 = strtok(args,",");
			token = strtok(NULL,",");
			filename = strtok(NULL,",[]");
			token = strtok(objtoken1," []");
			token = strtok(NULL," []"); if(!token) return 0;
			sscanf(token,"%X",&handle1);
			//Update typing structure
			pathCompletion(filename);
			objind = isKnownObject(types,filename,0);
			if(objind==-1){
				//If unknown, create new object
				objind = addNewObject(types,filename,OBJ_FILE);
				setObjectStatus(types,objind,1);
			}
			if(handle1) addObjectHandle(types,objind,handle1);
			*obj1 = objind;
		}
		return OP_OPEN;
	}

	if(!strncasecmp(OPENF2,line,15)){//NtCreateSection Size n=15
		args = strchr(line,'(');
		if(args){
			//Parse arguments
			args++;
			objtoken1 = strtok(args,",");
			token = strtok(NULL,","); 
			token = strtok(NULL,",");
			token = strtok(NULL,",");
			token = strtok(NULL,",");
			token = strtok(NULL,",");
			token = strtok(NULL,",[]) "); if(!token) return 0;
			sscanf(token,"%X",&handle2);
			token = strtok(objtoken1," []");
			token = strtok(NULL," []"); if(!token) return 0;
			sscanf(token,"%X",&handle1);
			if(!handle2) return 0; //A changer
			//Update typing structure
			objind = isKnownObject(types,NULL,handle2);
			if(objind==-1){
				//If unknown or 0, createsection create an independent new object
				objind = addNewObject(types,NULL,OBJ_FILE);
				if(handle2) addObjectHandle(types,objind,handle2);
				*obj1 = objind;
				return OP_CREA;
			}
			if(handle1) addObjectHandle(types,objind,handle1);
			*obj1 = objind;
		}
		return OP_OPEN;
	}

	if(!strncasecmp(CREATEF1,line,12)){//Size n=12
		int disposition, status;
		args = strchr(line,'(');
		if(args){
			//Parse arguments
			args++;
			objtoken1 = strtok(args,",");
			token = strtok(NULL,",");
			filename = strtok(NULL,",[]");
			objtoken2 = strtok(NULL,",");
			token = strtok(objtoken1," []");
			token = strtok(NULL," []"); if(!token) return 0;
			sscanf(token,"%X",&handle1);
			token = strtok(objtoken2," []");
			token = strtok(NULL," []"); 
			if(token) sscanf(token,"%d/%d",&status,&disposition);
			//Can be refined using parameter creation disposition
			//Update typing structure
			pathCompletion(filename);
			objind = isKnownObject(types,filename,0);
			if(objind==-1){
				//If unknown, create new object
				objind = addNewObject(types,filename,OBJ_FILE);
			}
			if(handle1) addObjectHandle(types,objind,handle1);
			*obj1 = objind;
		}
		if(disposition==1||status==1) return OP_OPEN;
		return OP_CREA;
	}

	if(!strncasecmp(CLOSE,line,7)){//Size n=7
		args = strchr(line,'(');
		if(args){
			//Parse arguments
			args++;
			token = strtok(args," ,[])"); if(!token) return 0;
			sscanf(token,"%X",&handle1);

			//Update typing structure
			objind = isKnownObject(types,NULL,handle1);
			if(objind==-1){
				//If unknown, close must fail
				return 0;
			}
			removeObjectHandle(types,objind,handle1);
			*obj1 = objind;
		}
		return OP_CLOS;
	}

	if(!strncasecmp(DELETEF1,line,12)){//Size n=12
		args = strchr(line,'(');
		if(args){
			//Parse arguments
			args++;
			filename = strtok(args," ,[])");
			//Update typing structure
			pathCompletion(filename);
			objind = isKnownObject(types,filename,0);
			if(objind==-1){
				//If unknown, create new object
				objind = addNewObject(types,filename,OBJ_FILE);
			}
			*obj1 = objind;
		}
		return OP_DEL;
	}

	if(!strncasecmp(EXECF1,line,17)){//NtCreateProcessEx Size n=17
		args = strchr(line,'(');
		if(args){
			//Parse arguments
			args++;
			objtoken1 = strtok(args,",");	//process handle
			token = strtok(NULL,",");		//access
			token = strtok(NULL,",");		//attributes
			token = strtok(NULL,",");		//parent
			token = strtok(NULL,",");		//flags
			objtoken2 = strtok(NULL,",");	//section
			token = strtok(objtoken1," []");
			token = strtok(NULL," []"); if(!token) return 0;
			sscanf(token,"%X",&handle1);
			sscanf(objtoken2,"%X",&handle2);

			//Update typing structure
			objind = isKnownObject(types,NULL,handle2);
			if(objind==-1) return 0; //Ignore unknown section (unknown process)
			if(handle1) addObjectHandle(types,objind,handle1);
			*obj1 = objind;
		}
		return OP_EXEC;
	}

	return 0;
}

unsigned long monitorFileIO(struct TYPING * types, char * line, int * obj1, int * obj2){
	char * args = NULL; 
	char * token; char * objtoken1; char * objtoken2;
	unsigned long ptr1, handle1, ptr2, handle2;
	int i, size, offset, objind1, objind2, exactptr = 0;
	unsigned long add, diff;
	
	if(!strncasecmp(READF1,line,10)		//NtReadFile Size n=strlen(READF1)-1
		||!strncasecmp(READF2,line,17)){	//NtReadFileScatter Size n=strlen(READF2)-1
		args = strchr(line,'(');
		if(args){
			//Parse arguments
			args++;
			token = strtok(args,",");
			sscanf(token,"%X",&handle2);
			token = strtok(NULL,","); token = strtok(NULL,",");
			token = strtok(NULL,","); token = strtok(NULL,",");
			token = strtok(NULL,", "); if(!token) return 0;
			sscanf(token,"%X",&ptr1);
			token = strtok(NULL,", "); 
			if(token) sscanf(token,"%X",&size);
			objtoken1 = strtok(NULL,",)");
			token = strtok(objtoken1,"[]");
			token = strtok(NULL,"[]");;
			if(token) sscanf(token,"%X",&offset);
			
			//Update typing structure
			objind2 = isKnownObject(types,NULL,handle2);
			if(objind2==-1){
				return 0;
				/*//If unknown, create new object
				objind2 = addNewObject(types,NULL,OBJ_FILE);
				addObjectHandle(types,objind2,handle2);*/
			}
			*obj2 = objind2;
			
			//If known, restrain address size
			objind1 = 0;
			for(i=0;i<types->nbobj;i++){
				unsigned long add = getObjectAddress(types,i);
				int addsize = getObjectSize(types,i);;
				//Checks addresses
				if(ptr1>=add && ptr1<(add+addsize)){
					if(add==ptr1){
						if(!objind1) objind1 = i;
					}else{
						diff = ptr1-add-1;
						setObjectSize(types,i,(int)diff);
					}
				}
			}
			//Create new variable
			if(!objind1){
				objind1 = addNewObject(types,NULL,VAR);
				setObjectAddress(types,objind1,ptr1);
			}
			setObjectSize(types,objind1,size);
			*obj1 = objind1;	
		}
		return OP_READ;
	}

	if(!strncasecmp(READF3,line,18)){	//NtMapViewOfSection Size n=strlen(READF3)-1
		args = strchr(line,'(');
		if(args){
			//Parse arguments
			args++;
			token = strtok(args,","); 
			sscanf(token,"%X",&handle2);
			token = strtok(NULL,","); 
			objtoken1 = strtok(NULL,",");
			token = strtok(NULL,","); token = strtok(NULL,",");
			token = strtok(NULL,",");
			objtoken2 = strtok(NULL,",");
			token = strtok(objtoken1,"[] ");
			token = strtok(NULL,"[] ");
			sscanf(token,"%X",&ptr1);
			token = strtok(objtoken2,"[] ");
			token = strtok(NULL,"[] ");
			sscanf(token,"%X",&size);
			
			//Update typing structure
			objind2 = isKnownObject(types,NULL,handle2);
			if(objind2==-1){
				return 0;
				/*//If unknown, create new object
				objind2 = addNewObject(types,NULL,OBJ_FILE);
				addObjectHandle(types,objind2,handle2);*/
			}
			*obj2 = objind2;
			
			//If known, restrain address size
			objind1 = 0;
			for(i=0;i<types->nbobj;i++){
				unsigned long add = getObjectAddress(types,i);
				int addsize = getObjectSize(types,i);;
				//Checks addresses
				if(ptr1>=add && ptr1<(add+addsize)){
					if(add==ptr1){
						if(!objind1) objind1 = i;
					}else{
						diff = ptr1-add-1;
						setObjectSize(types,i,(int)diff);
					}
				}
			}
			//Create new variable
			if(!objind1){
				objind1 = addNewObject(types,NULL,VAR);
				setObjectAddress(types,objind1,ptr1);
			}
			setObjectSize(types,objind1,size);
			*obj1 = objind1;
			
			/*objind1 = isKnownObject(types,NULL,ptr1);
			if(objind1>-1){
				//If known, restrain address size
				add = getObjectAddress(types,objind1);
				if(add!=ptr1){
					//Restrain size
					diff = ptr1-add-1;
					setObjectSize(types,objind1,(int)diff);
					//Create new variable
					objind1 = addNewObject(types,NULL,VAR);
					setObjectAddress(types,objind1,ptr1);
				}
			}else{
				//Create new variable
				objind1 = addNewObject(types,NULL,VAR);
				setObjectAddress(types,objind1,ptr1);
			}
			setObjectSize(types,objind1,size);
			*obj1 = objind1;*/
		}
		return OP_READ;
	}

	if(!strncasecmp(WRITEF1,line,11)		//NtWriteFile Size n=strlen(WRITEF1)-1
		||!strncasecmp(WRITEF2,line,17)){	//NtWriteFileGather Size n=strlen(WRITEF2)-1
		args = strchr(line,'(');
		if(args){
			//Parse arguments
			args++;
			token = strtok(args,",");
			sscanf(token,"%X",&handle2);
			token = strtok(NULL,","); token = strtok(NULL,",");
			token = strtok(NULL,","); token = strtok(NULL,",");
			token = strtok(NULL,", "); if(!token) return 0;
			sscanf(token,"%X",&ptr1);
			token = strtok(NULL,", ");
			sscanf(token,"%X",&size);
			objtoken1 = strtok(NULL,",)");
			token = strtok(objtoken1,"[]");
			token = strtok(NULL,"[]");;
			if(token) sscanf(token,"%X",&offset);
			
			//Update typing structure
			objind2 = isKnownObject(types,NULL,handle2);
			if(objind2==-1){
				return 0;
				/*//If unknown, create new object
				objind2 = addNewObject(types,NULL,OBJ_FILE);
				addObjectHandle(types,objind2,handle2);*/
			}
			*obj2 = objind2;
			objind1 = isKnownObject(types,NULL,ptr1);
			if(objind1==-1){
				//If unknown, create new object
				objind1 = addNewObject(types,NULL,VAR);
				setObjectAddress(types,objind1,ptr1);
				setObjectSize(types,objind1,size);
			}
			*obj1 = objind1;
		}
		return OP_WRITE;
	}

	return 0;
}

unsigned long monitorRegControl(struct TYPING * types, char * line, int * obj1){
	char * args = NULL; 
	char * token; char * objtoken1; char * keyname;
	unsigned long handle;
	int objind;

	if(!strncasecmp(OPENR1,line,10)){//NtOpenKey( Size n=strlen(OPENR1)-1)
		args = strchr(line,'(');
		if(args){
			//Parse arguments
			args++;
			objtoken1 = strtok(args,",");
			token = strtok(NULL,",");
			keyname = strtok(NULL,",[])");
			token = strtok(objtoken1," []");
			token = strtok(NULL," []");
			if(token) sscanf(token,"%X",&handle);
			//Update typing structure
			objind = isKnownObject(types,keyname,0);
			if(objind==-1){
				//If unknown, create new object
				objind = addNewObject(types,keyname,OBJ_REG);
				setObjectStatus(types,objind,1);
			}
			if(handle) addObjectHandle(types,objind,handle);
			*obj1 = objind;
		}
		return OP_OPEN;
	}

	if(!strncasecmp(CREATER1,line,11)){//NtCreateKey Size n=strlen(CREATER1)-1)
		args = strchr(line,'(');
		if(args){
			//Parse arguments
			args++;
			objtoken1 = strtok(args,",");
			token = strtok(NULL,",");
			keyname = strtok(NULL,",[])");
			token = strtok(objtoken1," []");
			token = strtok(NULL," []");
			if(token) sscanf(token,"%X",&handle);
			//Update typing structure
			objind = isKnownObject(types,keyname,0);
			if(objind==-1){
				//If unknown, create new object
				objind = addNewObject(types,keyname,OBJ_REG);
			}
			if(handle) addObjectHandle(types,objind,handle);
			*obj1 = objind;
		}
		return OP_CREA;
	}

	if(!strncasecmp(DELETER1,line,11)){//Size n=11
		args = strchr(line,'(');
		if(args){
			//Parse arguments
			args++;
			token = strtok(args," ,)");
			sscanf(token,"%X",&handle);
			//Update typing structure
			objind = isKnownObject(types,NULL,handle);
			if(objind==-1){
				return 0;
				/*//If unknown, create new object
				objind = addNewObject(types,NULL,OBJ_REG);
				addObjectHandle(types,objind,handle);*/
			}
			*obj1 = objind;
		}
		return OP_DEL;
	}
	return 0;
}

unsigned long monitorRegIO(struct TYPING * types, char * line, int * obj1, int * obj2){
	char * args = NULL; 
	char * token; char * valuename;
	unsigned long add, diff, handle, ptr;
	int size = 0, objind1, objind2;
	
	if(!strncasecmp(READR1,line,15)){	//NtQueryValueKey Size n=15
		args = strchr(line,'(');
		if(args){
			//Parse arguments
			args++;
			token = strtok(args,","); if(!token) return 0;
			sscanf(token,"%X",&handle);
			valuename = strtok(NULL,",");
			token = strtok(NULL,",");
			token = strtok(NULL,","); if(!token) return 0;
			sscanf(token,"%X",&ptr);
			token = strtok(NULL,",");
			token = strtok(NULL,",");
			token = strtok(token,"[] ");
			token = strtok(NULL,"[] ");
			if(token) sscanf(token,"%X",&size);

			//Update typing structure
			objind2 = isKnownObject(types,NULL,handle);
			if(objind2==-1){
				return 0;
				/*//If unknown, create new object
				objind2 = addNewObject(types,NULL,OBJ_REG);
				addObjectHandle(types,objind2,handle);*/
			}
			*obj2 = objind2;
			objind1 = isKnownObject(types,NULL,ptr);
			if(objind1==-1){
				//If unknown, create new object
				objind1 = addNewObject(types,valuename,VAR);
				setObjectAddress(types,objind1,ptr);
			}
			setObjectSize(types,objind1,size);
			*obj1 = objind1;
		}
		return OP_READ;
	}

	if(!strncasecmp(WRITER1,line,13)){	//NtSetValueKey Size n=13
		args = strchr(line,'(');
		if(args){
			//Parse arguments
			args++;
			token = strtok(args,","); if(!token) return 0;
			sscanf(token,"%X",&handle);
			valuename = strtok(NULL,",");
			token = strtok(NULL,",");
			token = strtok(NULL,",");
			token = strtok(NULL,","); if(!token) return 0;
			sscanf(token,"%X",&ptr);
			token = strtok(NULL,",)");
			sscanf(token,"%X",&size);

			//Update typing structure
			objind2 = isKnownObject(types,NULL,handle);
			if(objind2==-1){
				return 0;
				/*//If unknown, create new object
				objind2 = addNewObject(types,NULL,OBJ_REG);
				addObjectHandle(types,objind2,handle);*/
			}
			*obj2 = objind2;
			objind1 = isKnownObject(types,NULL,ptr);
			if(objind1==-1){
				//If unknown, create new object
				objind1 = addNewObject(types,valuename,VAR);
				setObjectAddress(types,objind1,ptr);
			}
			setObjectSize(types,objind1,size);
			*obj1 = objind1;	
		}
		return OP_WRITE;
	}

	return 0;
}

unsigned long monitorNetworkControl(struct TYPING * types, char * line, int * obj1){
	return 0;
}

unsigned long monitorNetworkIO(struct TYPING * types, char * line, int * obj1, int * obj2){
	char * args = NULL; 
	char * token; 
	char * objtoken1; char * objtoken2; char * objtoken3;
	unsigned long add, diff, handle, code, input, output, operation = 0;
	int rsize, isize, osize, objind1, objind2;
	
	if(!strncasecmp(RWN1,line,strlen(RWN1)-1)){	//NtDeviceIOControlFile Size n=?
		args = strchr(line,'(');
		if(args){
			//Parse arguments
			args++;
			token = strtok(args,","); if(!token) return 0;
			sscanf(token,"%X",&handle);
			token = strtok(NULL,","); token = strtok(NULL,","); token = strtok(NULL,","); 
			objtoken3 = strtok(NULL,",");
			token = strtok(NULL,", "); 
			if(!token) return 0;
			sscanf(token,"%X",&code);
			objtoken1 = strtok(NULL,", ");
			token = strtok(NULL,", "); 
			sscanf(token,"%X",&isize);
			if(isize) sscanf(objtoken1,"%X",&input);
			objtoken2 = strtok(NULL,", ");
			token = strtok(NULL,", ");
			sscanf(token,"%X",&osize);
			if(osize) sscanf(objtoken2,"%X",&output);
			token = strtok(objtoken3,"/");
			token = strtok(NULL,"]");
			sscanf(token,"%X",&rsize);

			//Checks operation code
			if(code==IOCTL_AFD_RECV||code==IOCTL_AFD_RECV_DATAGRAM){
				operation = OP_READ;
			}
			if(code==IOCTL_AFD_SEND||code==IOCTL_AFD_SEND_DATAGRAM){
				operation = OP_WRITE;
			}

			if(operation){
				//Update typing structure
				objind2 = isKnownObject(types,NULL,handle);
				if(objind2==-1){
					return 0;
					/*//If unknown, create new object
					objind2 = addNewObject(types,NULL,OBJ_FILE);
					addObjectHandle(types,objind2,handle);*/
				}
				*obj2 = objind2;
				objind1 = isKnownObject(types,NULL,input);
				if(objind1==-1){
					//If unknown, create new object
					objind1 = addNewObject(types,NULL,VAR);
					setObjectAddress(types,objind1,input);
					setObjectSize(types,objind1,rsize);
				}else if(operation == OP_READ){
					//If known, restrain address size
					add = getObjectAddress(types,objind1);
					if(add!=input){
						//Restrain size
						diff = input-add-1;
						setObjectSize(types,objind1,(int)diff);
						//Create new variable
						objind1 = addNewObject(types,NULL,VAR);
						setObjectAddress(types,objind1,input);
					}
					setObjectSize(types,objind1,rsize);
				}
				*obj1 = objind1;
			}
		}
		return operation;
	}

	return 0;
}
/** End System call monitoring **************************************************************/

void formatLogEntries(FILE * logf, struct TYPING * types,
					unsigned long operation, int obj1, int obj2){
	//Previous operation
	static unsigned long prevop = 0;
	static int prevobj1 = 0;
	static int prevobj2 = 0;
	//Ante previous operation
	static unsigned long pprevop = 0;
	static int pprevobj1 = 0;
	static int pprevobj2 = 0;
	
	static int consecutive = 0;

	//Checks for identical operation 
	if(!pprevop){//First iteration
		pprevop = operation;
		pprevobj1 = obj1;
		pprevobj2 = obj2;
		return;
	}
	if(pprevop&&!prevop){//Second iteration
		prevop = operation;
		prevobj1 = obj1;
		prevobj2 = obj2;
		return;
	}
	//Cas de la boucle sur une simple operation (loops AAAA....)
	if(pprevop==prevop && pprevobj1==prevobj1 && pprevobj2==prevobj2){
		//Poursuite de la boucle
		if(operation==prevop && obj1==prevobj1 && obj2==prevobj2) return;
		//Sinon la boucle est interrompue, on formatte la boucle
		printLogEntry(logf,types,L_LOOP,0,0);
		printLogEntry(logf,types,prevop,prevobj1,prevobj2);
		printLogEntry(logf,types,R_LOOP,0,0);
		//On relance la detection de boucle avec la nouvelle entree
		prevop = 0;
		pprevop = operation;
		pprevobj1 = obj1;
		pprevobj2 = obj2;
		return;

	//Cas de la boucle sur une double operation (loops ABABAB....)
	}else{
		if(consecutive%2==0){//1ere operation attendue
			if(pprevop==operation && pprevobj1==obj1 && pprevobj2==obj2){
				consecutive++; return;
			}else{
				//La boucle est interrompue, on formatte la boucle si nécessaire
				if(consecutive>=2) printLogEntry(logf,types,L_LOOP,0,0);
				printLogEntry(logf,types,pprevop,pprevobj1,pprevobj2);
				if(consecutive>=2) printLogEntry(logf,types,prevop,prevobj1,prevobj2);
				if(consecutive>=2) printLogEntry(logf,types,R_LOOP,0,0);
				//On relance la detection de boucle avec la nouvelle entree
				if(consecutive>=2){
					prevop = 0;
					pprevop = operation;
					pprevobj1 = obj1;
					pprevobj2 = obj2;
				}else{
					pprevop = prevop;		prevop = operation;
					pprevobj1 = prevobj1;	prevobj1 = obj1;
					pprevobj2 = prevobj2;	prevobj2 = obj2;
				}
				consecutive = 0;
				return;
			}
		}else{//2nde operation attendue
			if(prevop==operation && prevobj1==obj1 && prevobj2==obj2){
				consecutive++; return;
			}else{
				//La boucle est interrompue, on formatte la boucle si nécessaire
				if(consecutive>=2) printLogEntry(logf,types,L_LOOP,0,0);
				printLogEntry(logf,types,pprevop,pprevobj1,pprevobj2);
				printLogEntry(logf,types,prevop,prevobj1,prevobj2);
				if(consecutive>=2) printLogEntry(logf,types,R_LOOP,0,0);
				//On relance la detection de boucle avec la nouvelle entree
				prevop = operation;
				prevobj1 = obj1;
				prevobj2 = obj2;
				consecutive = 0;
				return;
			}
		}
	}
}


void printLogEntry(FILE * logf, struct TYPING * types,
				   unsigned long operation, int obj1, int obj2){
	unsigned long data = 0;

	//Logging operations according to desired format
	if(!operation) return;
	//Operation
	if(textual){
		switch(operation){
			case OP_OPEN:
				fprintf(logf,"Open ");
				break;
			case OP_CREA:
				fprintf(logf,"Create ");
				break;
			case OP_CLOS:
				fprintf(logf,"Close ");
				break;
			case OP_DEL:
				fprintf(logf,"Delete ");
				break;
			case OP_EXEC:
				fprintf(logf,"Execute ");
				break;
			case OP_READ:
				fprintf(logf,"Read ");
				break;
			case OP_WRITE:
				fprintf(logf,"Write ");
				break;
			case L_LOOP:
				fprintf(logf,"(\n");
				return;
			case R_LOOP:
				fprintf(logf,")*\n");
				return;
		}
	}
	if(!textual){
		data = operation;
		fwrite(&data,sizeof(long),1,logf);
	}
	if(operation==L_LOOP || operation==R_LOOP) return; 
	//1st argument
	if(textual){fprintf(logf,"%s%d",typestr[getObjectType(types,obj1)],obj1);
	}else{
		data = typebin[getObjectType(types,obj1)];
		fwrite(&data,sizeof(long),1,logf);
		data = obj1;
		fwrite(&data,sizeof(long),1,logf);
	}
	//2nd argument
	if(operation== OP_AFF){
		if(textual){fprintf(logf," := %s%d",typestr[getObjectType(types,obj2)],obj2);
		}else{
			data = typebin[getObjectType(types,obj2)];
			fwrite(&data,sizeof(long),1,logf);
			data = obj2;
			fwrite(&data,sizeof(long),1,logf);
		}
	}else if(operation == OP_READ){
		if(textual){fprintf(logf," <- %s%d",typestr[getObjectType(types,obj2)],obj2);
		}else{
			data = typebin[getObjectType(types,obj2)];
			fwrite(&data,sizeof(long),1,logf);
			data = obj2;
			fwrite(&data,sizeof(long),1,logf);
		}
	}else if(operation == OP_WRITE){
		if(textual){fprintf(logf," -> %s%d",typestr[getObjectType(types,obj2)],obj2);
		}else{
			data = typebin[getObjectType(types,obj2)];
			fwrite(&data,sizeof(long),1,logf);
			data = obj2;
			fwrite(&data,sizeof(long),1,logf);
		}
	}
	//End operation
	if(textual) fprintf(logf,";\n");
}



